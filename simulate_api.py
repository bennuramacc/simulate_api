# -*- coding: utf-8 -*-
"""simulate_api

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAKQUwNns-7l24zlWkSdxb9nZJlEwHiq
"""
# simulate_api.py
import os, re, random, datetime as dt
from dataclasses import dataclass, field
from typing import List, Tuple

import numpy as np
import pandas as pd
import simpy
from catboost import CatBoostRegressor
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ─── DOSYA YOLLARI ───────────────────────────────────────────────────
BASE_DIR     = os.path.dirname(__file__)
TRAVEL_XLSX  = os.path.join(BASE_DIR, "Travel Times & Dwell Times.xlsx")
ARRIVAL_XLS  = os.path.join(BASE_DIR, "passenger_arrival_rates_by_stop.xlsx")
DEST_XLS     = os.path.join(BASE_DIR, "DestinationProbabilities_Corrected.xlsx")
MODEL_PATH   = os.path.join(BASE_DIR, "segment_model.cbm")

# ─── 1) Travel + Dwell Tablosu ───────────────────────────────────────
def build_stops() -> pd.DataFrame:
    df = pd.read_excel(TRAVEL_XLSX, sheet_name=0, header=1)
    df = df.loc[:, ~df.columns.str.contains("Unnamed")]
    df.columns = df.columns.str.strip()
    trav = (
        df[["From","To","KM","Duration (sec)"]]
        .rename(columns={"From":"stop","To":"next","KM":"km","Duration (sec)":"travel_min"})
    )
    dwell_col = [c for c in df.columns if c.endswith("(sec).1")][0]
    dwell     = df[["Station", dwell_col]].rename(columns={"Station":"stop", dwell_col:"dwell_sec"})
    return trav.merge(dwell, on="stop").dropna().reset_index(drop=True)

SEG_DF = build_stops()

# ─── 2) Arrival Rates ─────────────────────────────────────────────────
arrival_sheets = pd.read_excel(ARRIVAL_XLS, sheet_name=None)
time_re = re.compile(r"^\d{2}:\d{2}-\d{2}:\d{2}$")
ARRIVAL_MAP = {}
for name, df in arrival_sheets.items():
    df = df.set_index(df.columns[0])
    cols = [c for c in df.columns if time_re.match(c)]
    ARRIVAL_MAP[name] = df[cols]

day_map = {
    "Monday":"Pazartesi","Tuesday":"Salı","Wednesday":"Çarşamba",
    "Thursday":"Perşembe","Friday":"Cuma","Saturday":"Cumartesi","Sunday":"Pazar"
}
ARRIVAL_SCALE = 600

def get_stop_lambda(stop: str, now: dt.datetime) -> float:
    df = ARRIVAL_MAP.get(stop)
    if df is None: return 0.0
    tur_day = day_map[now.strftime("%A")]
    row     = df.loc[tur_day] if tur_day in df.index else df.iloc[-1]
    m       = now.hour*60 + now.minute
    for col,val in row.items():
        s,e = col.split("-")
        smin = int(s[:2])*60 + int(s[3:])
        emin = int(e[:2])*60 + int(e[3:])
        if (smin<=m<emin) or (smin>emin and (m>=smin or m<emin)):
            return float(val)
    return float(row.iloc[-1])

# ─── 3) Destination Probabilities ────────────────────────────────────
raw_dp = pd.read_excel(DEST_XLS, sheet_name=0, index_col=0)
dp     = raw_dp.div(raw_dp.sum(axis=1), axis=0).fillna(0)
DEST_MAP = {o:(dp.columns.tolist(), dp.loc[o].tolist()) for o in dp.index}

# ─── 4) CatBoost + Özellikler ───────────────────────────────────────
CAT = CatBoostRegressor(); CAT.load_model(MODEL_PATH)

FEAT_NAMES = [
 'weather_temp','HOUR',
 'DAY_OF_WEEK_1','DAY_OF_WEEK_2','DAY_OF_WEEK_3','DAY_OF_WEEK_4','DAY_OF_WEEK_5','DAY_OF_WEEK_6',
 'HOLIDAY_CATEGORY_Normal','HOLIDAY_CATEGORY_Holiday',
 'MONTH_2','MONTH_3','MONTH_4','MONTH_5','MONTH_6','MONTH_7','MONTH_8','MONTH_9','MONTH_10','MONTH_11','MONTH_12',
 'PANDEMIC_CONDITION_Pandemic','SCHOOL_STATUS_School Open',
 'weather_description_Cloudy','weather_description_Low Visibility',
 'weather_description_Precipitation','weather_description_Storm',
 'HATSURESI_LAG_1','HATSURESI_LAG_2','HATSURESI_LAG_3','HATSURESI_LAG_4','HATSURESI_LAG_5'
]

@dataclass(frozen=True)
class BusType:
    name: str
    capacity: int

STD, ARTIC = BusType("Standard",90), BusType("Körüklü",120)

@dataclass
class Scenario:
    weather_desc: str
    temp: float
    demand_multiplier: float
    is_school_day: bool
    is_public_holiday: bool
    is_pandemic: bool = False
    bus_type: BusType = field(default_factory=lambda:STD)

def make_features(now: dt.datetime, sc: Scenario, km: float, lags: List[float]) -> List[float]:
    f = {n:0 for n in FEAT_NAMES}
    f["HOUR"] = now.hour
    f["weather_temp"] = sc.temp
    f[f"DAY_OF_WEEK_{now.weekday()+1}"] = 1
    if 2 <= now.month <= 12:
        f[f"MONTH_{now.month}"] = 1
    f["HOLIDAY_CATEGORY_Holiday"] = int(sc.is_public_holiday)
    f["HOLIDAY_CATEGORY_Normal"]  = int(not sc.is_public_holiday)
    f["SCHOOL_STATUS_School Open"]   = int(sc.is_school_day)
    f["PANDEMIC_CONDITION_Pandemic"] = int(sc.is_pandemic)
    wd_key = f"weather_description_{sc.weather_desc}"
    if wd_key in f: f[wd_key] = 1

    l = (lags + [0]*5)[:5]
    for i,v in enumerate(l,1):
        f[f"HATSURESI_LAG_{i}"] = v

    return [f[n] for n in FEAT_NAMES]

# ─── 5) Simülasyon Süreci ────────────────────────────────────────────
LOG: List[dict] = []
CURRENT_THR = 90

class Bus:
    def __init__(self,env,name,dep,sc):
        self.env, self.name, self.dep, self.sc = env,name,dep,sc
        self.curr_time = dep
        self.seg       = SEG_DF.copy()
        self.pax       = []
        self.max_occ   = 0
        env.process(self.run())

    def run(self):
        base = dt.datetime.combine(self.dep.date(), dt.time())
        yield self.env.timeout((self.dep-base).total_seconds()/60)

        lags, total = [0]*5, 0.0
        for r in self.seg.itertuples():
            now, stop, km = self.curr_time, r.stop, r.km

            # travel
            feat = make_features(now,self.sc,km,lags)
            sec  = float(CAT.predict([feat])[0])
            dur  = sec/60
            if self.sc.weather_desc in ("Storm","Precipitation"):
                dur *= 1.1
            lags = [dur]+lags[:4]
            total += dur
            yield self.env.timeout(dur)
            self.curr_time += dt.timedelta(minutes=dur)

            # al inen
            out = [p for p in self.pax if p==stop]
            self.pax = [p for p in self.pax if p!=stop]

            # binen
            lam = get_stop_lambda(stop,now)*ARRIVAL_SCALE*self.sc.demand_multiplier
            nin = np.random.poisson(lam*dur)
            dests,probs = DEST_MAP.get(stop,([],[]))
            new = list(np.random.choice(dests,size=nin,p=probs)) if dests else [stop]*nin
            self.pax.extend(new)
            self.max_occ = max(self.max_occ, len(self.pax))

            # dwell
            dwell = r.dwell_sec/60 + len(out)*0.03 + nin*0.01
            if self.sc.is_school_day:    dwell *= 1.1
            if self.sc.is_public_holiday: dwell *= 1.2
            total += dwell
            yield self.env.timeout(dwell)
            self.curr_time += dt.timedelta(minutes=dwell)

        LOG.append({
            "trip":      self.name,
            "trip_time": round(total,2),
            "capacity":  self.sc.bus_type.capacity,
            "max_occ":   self.max_occ
        })

def run_day(sc: Scenario, slot_plan: List[Tuple[str,int]], date: dt.date=None) -> pd.DataFrame:
    global LOG
    LOG = []
    date = date or dt.date.today()
    env  = simpy.Environment()
    for k,(s,_) in enumerate(slot_plan):
        dep = dt.datetime.combine(date, pd.to_datetime(s).time())
        # expected
        now = dep
        exp = sum(
            get_stop_lambda(r.stop,now)*ARRIVAL_SCALE*sc.demand_multiplier*(r.travel_min/60)
            for r in SEG_DF.itertuples()
        )
        sc.bus_type = ARTIC if exp > CURRENT_THR else STD
        Bus(env, f"Trip{k}", dep, sc)
    env.run()
    return pd.DataFrame(LOG)

# ─── 6) FastAPI ve CORS ──────────────────────────────────────────────
app = FastAPI()
app.add_middleware(
  CORSMiddleware,
  allow_origins=["*"],
  allow_methods=["*"],
  allow_headers=["*"],
)

class SimRequest(BaseModel):
    weather_desc:    str
    temp:            float
    demand_multiplier: float
    is_school_day:   bool
    is_public_holiday: bool
    is_pandemic:     bool = False
    threshold:       int
    slots:           List[List[str]]

@app.post("/simulate")
async def simulate(req: SimRequest):
    global CURRENT_THR
    CURRENT_THR = req.threshold

    sc = Scenario(
      weather_desc=req.weather_desc,
      temp=req.temp,
      demand_multiplier=req.demand_multiplier,
      is_school_day=req.is_school_day,
      is_public_holiday=req.is_public_holiday,
      is_pandemic=req.is_pandemic
    )

    slot_plan = [(s, int(h) if h else None) for s,h in req.slots]
    df        = run_day(sc, slot_plan)
    df_trip   = (
      df.groupby("trip")
        .agg(time_min=("trip_time","first"),
             cap=("capacity","first"),
             max_occ=("max_occ","first"))
    )
    df_trip["load_%"] = 100 * df_trip["max_occ"] / df_trip["cap"]
    return df_trip.reset_index().to_dict(orient="records")
