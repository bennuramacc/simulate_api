# -*- coding: utf-8 -*-
"""simulate_api

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAKQUwNns-7l24zlWkSdxb9nZJlEwHiq
"""
import os
import re
import datetime as dt
import numpy as np
import pandas as pd
import simpy
from dataclasses import dataclass
from catboost import CatBoostRegressor

# ─── 0) File paths ────────────────────────────────────────────────
BASE_DIR    = os.path.dirname(__file__)
TRAVEL_XLSX = os.path.join(BASE_DIR, "Travel Times & Dwell Times.xlsx")
ARRIVAL_XLS = os.path.join(BASE_DIR, "passenger_arrival_rates_by_stop.xlsx")
DEST_PATH   = os.path.join(BASE_DIR, "DestinationProbabilities_Corrected.xlsx")
MODEL_PATH  = os.path.join(BASE_DIR, "segment_model.cbm")

# ─── 1) Build stops table ─────────────────────────────────────────
def build_stops():
    df = pd.read_excel(TRAVEL_XLSX, header=1)
    df = df.loc[:, ~df.columns.str.contains("^Unnamed")]
    df.columns = df.columns.str.strip()
    trav = df[["From","To","KM","Duration (sec)"]].rename(
        columns={"From":"stop","To":"next","KM":"km","Duration (sec)":"travel_min"})
    dcol = next(c for c in df.columns if c.endswith("(sec).1"))
    dwell = df[["Station", dcol]].rename(
        columns={"Station":"stop", dcol:"dwell_sec"})
    return trav.merge(dwell, on="stop").dropna().reset_index(drop=True)

SEG_DF = build_stops()

# ─── 2) Arrival‐rate map ───────────────────────────────────────────
sheets = pd.read_excel(ARRIVAL_XLS, sheet_name=None)
time_re = re.compile(r"^\d{2}:\d{2}-\d{2}:\d{2}$")
ARRIVAL = {}
for name, df in sheets.items():
    df = df.set_index(df.columns[0])
    ARRIVAL[name] = df[[c for c in df.columns if time_re.match(c)]]

DAY_MAP = {
    "Monday":"Pazartesi","Tuesday":"Salı","Wednesday":"Çarşamba",
    "Thursday":"Perşembe","Friday":"Cuma","Saturday":"Cumartesi","Sunday":"Pazar"
}
ARR_SCALE = 600.0

def get_lambda(stop, now):
    df = ARRIVAL.get(stop)
    if df is None: return 0.0
    day = DAY_MAP[now.strftime("%A")]
    if day not in df.index: return 0.0
    row = df.loc[day]
    m = now.hour*60 + now.minute
    for iv, val in row.items():
        s,e = iv.split("-")
        smin = int(s[:2])*60 + int(s[3:])
        emin = int(e[:2])*60 + int(e[3:])
        if (smin<=m<emin) or (smin>emin and (m>=smin or m<emin)):
            return float(val)
    return float(row.iloc[-1])

# ─── 3) Destination probabilities ─────────────────────────────────
dp_raw = pd.read_excel(DEST_PATH, index_col=0)
dp     = dp_raw.div(dp_raw.sum(axis=1), axis=0).fillna(0)
DEST   = {o:(list(dp.columns), dp.loc[o].tolist()) for o in dp.index}

# ─── 4) Load CatBoost model + feature list ───────────────────────
CAT = CatBoostRegressor()
CAT.load_model(MODEL_PATH)
FEATS = [
 'weather_temp','HOUR',
 'DAY_OF_WEEK_1','DAY_OF_WEEK_2','DAY_OF_WEEK_3',
 'DAY_OF_WEEK_4','DAY_OF_WEEK_5','DAY_OF_WEEK_6',
 'HOLIDAY_CATEGORY_Normal','HOLIDAY_CATEGORY_Holiday',
 'MONTH_1','MONTH_2','MONTH_3','MONTH_4','MONTH_5','MONTH_6',
 'MONTH_7','MONTH_8','MONTH_9','MONTH_10','MONTH_11','MONTH_12',
 'PANDEMIC_CONDITION_Pandemic','SCHOOL_STATUS_School Open',
 'weather_description_Cloudy','weather_description_Low Visibility',
 'weather_description_Precipitation','weather_description_Storm',
 'HATSURESI_LAG_1','HATSURESI_LAG_2','HATSURESI_LAG_3',
 'HATSURESI_LAG_4','HATSURESI_LAG_5'
]

def make_feats(now, sc, km, lags):
    f = {k:0 for k in FEATS}
    f["HOUR"] = now.hour
    f["weather_temp"] = sc.temp
    f[f"DAY_OF_WEEK_{now.weekday()+1}"] = 1
    f[f"MONTH_{now.month}"] = 1
    f["HOLIDAY_CATEGORY_Holiday"] = int(sc.is_public_holiday)
    f["HOLIDAY_CATEGORY_Normal"]  = int(not sc.is_public_holiday)
    f["SCHOOL_STATUS_School Open"]   = int(sc.is_school_day)
    f["PANDEMIC_CONDITION_Pandemic"] = int(sc.is_pandemic)
    wd = f"weather_description_{sc.weather_desc}"
    if wd in f: f[wd] = 1
    lags = (lags + [0]*5)[:5]
    for i,v in enumerate(lags,1):
        f[f"HATSURESI_LAG_{i}"] = v
    return [f[k] for k in FEATS]

# ─── 5) BusType & Scenario ────────────────────────────────────────
@dataclass(frozen=True)
class BusType:
    name: str
    capacity: int

STD   = BusType("Standard", 90)
ARTIC = BusType("Körüklü", 120)

@dataclass
class Scenario:
    weather_desc:      str
    temp:              float
    demand_multiplier: float
    is_school_day:     bool
    is_public_holiday: bool
    is_pandemic:       bool = False

# ─── 6) Simulate one trip ─────────────────────────────────────────
def one_trip(dep, sc):
    LOG = []
    env = simpy.Environment()

    class B:
        def __init__(self, env, dep, sc):
            self.env   = env
            self.dep   = dep
            self.sc    = sc
            self.curr  = dep
            self.seg   = SEG_DF.copy()
            self.pax   = []
            self.max_occ = 0
            self.boarded = 0
            self.lags  = [0]*5
            env.process(self.run())

        def run(self):
            # departure delay
            delay = (self.dep - dt.datetime.combine(self.dep.date(), dt.time())).seconds/60
            yield self.env.timeout(delay)
            trip_time = 0.0

            for r in self.seg.itertuples():
                now, stop, km = self.curr, r.stop, r.km
                df_feat = pd.DataFrame([make_feats(now, self.sc, km, self.lags)], columns=FEATS)
                sec     = float(CAT.predict(df_feat)[0])
                dur     = sec/60
                self.lags = [dur] + self.lags[:4]
                trip_time += dur
                yield self.env.timeout(dur)
                self.curr += dt.timedelta(minutes=dur)

                # alight
                out = [p for p in self.pax if p==stop]
                self.pax = [p for p in self.pax if p!=stop]

                # board
                lam = get_lambda(stop, now)*ARR_SCALE*self.sc.demand_multiplier
                if self.sc.is_public_holiday: lam *= 0.8
                nin = np.random.poisson(lam*dur)
                dests, probs = DEST.get(stop, ([],[]))
                new = (np.random.choice(dests, size=nin, p=probs).tolist()
                       if dests else [stop]*nin)
                self.pax.extend(new)
                self.boarded += nin
                self.max_occ  = max(self.max_occ, len(self.pax))

                # dwell
                dwell = (r.dwell_sec/60) + len(out)*0.03 + nin*0.01
                if self.sc.is_school_day:    dwell *= 1.1
                if self.sc.is_public_holiday:dwell *= 1.2
                trip_time += dwell
                yield self.env.timeout(dwell)
                self.curr += dt.timedelta(minutes=dwell)

            LOG.append({
                "depart_time": self.dep.strftime("%H:%M"),
                "bus_type":    self.sc.bus_type.name,
                "capacity":    self.sc.bus_type.capacity,
                "trip_time":   round(trip_time,2),
                "max_occ":     self.max_occ,
                "boarded":     self.boarded,
            })

    B(env, dep, sc)
    env.run()
    return LOG[0]

# ─── 7) Average baseline trip time ────────────────────────────────
def avg_trip(sc, start, end):
    times = pd.date_range(start=start, end=end, freq="30min").time
    vals = []
    for t in times:
        rec = one_trip(dt.datetime.combine(dt.date.today(), t), sc)
        vals.append(rec["trip_time"])
    return np.mean(vals)

# ─── 8) Dynamic‐slot‐day simulation ───────────────────────────────
def run_dynamic(sc, start="06:00", end="23:00"):
    base = avg_trip(sc, start, end)
    headway = 30
    recs = []
    dep = dt.datetime.combine(dt.date.today(), pd.to_datetime(start).time())
    end_dt = dt.datetime.combine(dt.date.today(), pd.to_datetime(end).time())

    while dep <= end_dt:
        out = one_trip(dep, sc)
        # adjust headway by trip_time vs base
        diff = out["trip_time"] - base
        if   diff > 30: headway = 10; sc.bus_type = ARTIC
        elif diff > 20: headway = 10
        elif diff > 10: headway = 15
        elif diff > 5:  headway = 20
        else:           headway = 30

        # triple counts
        out["headway"] = headway
        out["max_occ"] *= 3
        out["boarded"] *= 3
        out["load_%"]  = round(100*out["max_occ"]/out["capacity"], 2)

        # if still >90%, upgrade to articulated
        if out["load_%"] > 90:
            out["bus_type"] = ARTIC.name
            out["capacity"] = ARTIC.capacity
            out["load_%"]   = round(100*out["max_occ"]/out["capacity"], 2)

        recs.append(out)
        dep += dt.timedelta(minutes=headway)

    return pd.DataFrame(recs)

# ─── 9) Example & plotting ────────────────────────────────────────
if __name__ == "__main__":
    import matplotlib.pyplot as plt

    sc = Scenario("Rain", 16.0, 1.3, True, False)
    df = run_dynamic(sc)
    print(df)
    plt.figure(figsize=(8,3))
    plt.plot(df.depart_time, df.headway, "-o")
    plt.xticks(rotation=45)
    plt.ylabel("Headway (min)")
    plt.title("Dynamic Headways")
    plt.tight_layout()
    plt.show()

    plt.figure(figsize=(8,3))
    plt.plot(df.depart_time, df["load_%"], "-o")
    plt.xticks(rotation=45)
    plt.ylabel("Load (%)")
    plt.title("Loads")
    plt.tight_layout()
    plt.show()
