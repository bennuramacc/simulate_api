# -*- coding: utf-8 -*-
"""simulate_api

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aAKQUwNns-7l24zlWkSdxb9nZJlEwHiq
"""
# simulate_api.py (part 1 of 2)

import os, re, random, datetime as dt
from dataclasses import dataclass, field
from typing import List, Tuple

import numpy as np
import pandas as pd
import simpy
from catboost import CatBoostRegressor

# ─── 0) File paths ──────────────────────────────────────────────────
BASE_DIR    = os.path.dirname(__file__)
TRAVEL_XLSX = os.path.join(BASE_DIR, "Travel Times & Dwell Times.xlsx")
ARRIVAL_XLS = os.path.join(BASE_DIR, "passenger_arrival_rates_by_stop.xlsx")
DEST_PATH   = os.path.join(BASE_DIR, "DestinationProbabilities_Corrected.xlsx")
MODEL_PATH  = os.path.join(BASE_DIR, "segment_model.cbm")

# ─── 1) Build travel + dwell table ─────────────────────────────────
def build_stops() -> pd.DataFrame:
    df = pd.read_excel(TRAVEL_XLSX, sheet_name=0, header=1)
    df = df.loc[:, ~df.columns.str.contains("^Unnamed")]  # drop empty cols
    df.columns = df.columns.str.strip()
    trav = df[["From","To","KM","Duration (sec)"]].rename(
        columns={"From":"stop","To":"next","KM":"km","Duration (sec)":"travel_min"})
    dcol = [c for c in df if c.endswith("(sec).1")][0]
    dwell = df[["Station", dcol]].rename(
        columns={"Station":"stop", dcol:"dwell_sec"})
    return trav.merge(dwell, on="stop").dropna().reset_index(drop=True)

SEG_DF = build_stops()

# ─── 2) Arrival rates by stop/time ────────────────────────────────
arrival_sheets = pd.read_excel(ARRIVAL_XLS, sheet_name=None)
time_re = re.compile(r"^\d{2}:\d{2}-\d{2}:\d{2}$")
ARRIVAL_MAP = {}
for name, df in arrival_sheets.items():
    df = df.set_index(df.columns[0])
    cols = [c for c in df.columns if time_re.match(c)]
    ARRIVAL_MAP[name] = df[cols]

DAY_MAP = {
    "Monday":"Pazartesi","Tuesday":"Salı","Wednesday":"Çarşamba",
    "Thursday":"Perşembe","Friday":"Cuma","Saturday":"Cumartesi","Sunday":"Pazar"
}
ARRIVAL_SCALE = 600.0

def get_stop_lambda(stop: str, now: dt.datetime) -> float:
    df = ARRIVAL_MAP.get(stop)
    if df is None: return 0.0
    day = DAY_MAP[now.strftime("%A")]
    if day not in df.index: return 0.0
    row = df.loc[day]
    m = now.hour*60 + now.minute
    for interval, val in row.items():
        s,e = interval.split("-")
        smin = int(s[:2])*60 + int(s[3:])
        emin = int(e[:2])*60 + int(e[3:])
        if (smin <= m < emin) or (smin>emin and (m>=smin or m<emin)):
            return float(val)
    return float(row.iloc[-1])

# ─── 3) Estimate expected load for bus type decision ──────────────
def estimate_expected_load(dep: dt.datetime, sc: "Scenario") -> float:
    now, tot = dep, 0.0
    for r in SEG_DF.itertuples():
        lam = get_stop_lambda(r.stop, now) * ARRIVAL_SCALE * sc.demand_multiplier
        tot += lam * (r.travel_min/60)
        now += dt.timedelta(minutes=r.travel_min)
    return tot

# ─── 4) Destination probabilities ─────────────────────────────────
dp_raw = pd.read_excel(DEST_PATH, sheet_name=0, index_col=0)
dp     = dp_raw.div(dp_raw.sum(axis=1), axis=0).fillna(0)
DEST_MAP = {orig:(list(dp.columns), dp.loc[orig].tolist()) for orig in dp.index}

# ─── 5) Load CatBoost model + feature list ────────────────────────
CAT   = CatBoostRegressor()
CAT.load_model(MODEL_PATH)
FEATS = [
 'weather_temp','HOUR',
 'DAY_OF_WEEK_1','DAY_OF_WEEK_2','DAY_OF_WEEK_3',
 'DAY_OF_WEEK_4','DAY_OF_WEEK_5','DAY_OF_WEEK_6',
 'HOLIDAY_CATEGORY_Normal','HOLIDAY_CATEGORY_Holiday',
 'MONTH_2','MONTH_3','MONTH_4','MONTH_5','MONTH_6',
 'MONTH_7','MONTH_8','MONTH_9','MONTH_10','MONTH_11','MONTH_12',
 'PANDEMIC_CONDITION_Pandemic','SCHOOL_STATUS_School Open',
 'weather_description_Cloudy','weather_description_Low Visibility',
 'weather_description_Precipitation','weather_description_Storm',
 'HATSURESI_LAG_1','HATSURESI_LAG_2','HATSURESI_LAG_3',
 'HATSURESI_LAG_4','HATSURESI_LAG_5'
]

def make_features(now: dt.datetime,
                  sc: "Scenario",
                  km: float,
                  lags: List[float]) -> List[float]:
    f = {k:0 for k in FEATS}
    f["HOUR"] = now.hour
    f["weather_temp"] = sc.temp
    f[f"DAY_OF_WEEK_{now.weekday()+1}"] = 1
    f[f"MONTH_{now.month}"] = 1
    f["HOLIDAY_CATEGORY_Holiday"] = int(sc.is_public_holiday)
    f["HOLIDAY_CATEGORY_Normal"]  = int(not sc.is_public_holiday)
    f["SCHOOL_STATUS_School Open"]   = int(sc.is_school_day)
    f["PANDEMIC_CONDITION_Pandemic"] = int(sc.is_pandemic)
    wd = f"weather_description_{sc.weather_desc}"
    if wd in f: f[wd] = 1
    lags = (lags + [0]*5)[:5]
    for i,v in enumerate(lags,1):
        f[f"HATSURESI_LAG_{i}"] = v
    return [f[k] for k in FEATS]

# ─── 6) Scenario & BusType dataclasses ─────────────────────────────
@dataclass(frozen=True)
class BusType:
    name: str
    capacity: int

STD   = BusType("Standard", 90)
ARTIC = BusType("Körüklü", 120)

@dataclass
class Scenario:
    weather_desc:      str
    temp:              float
    demand_multiplier: float
    is_school_day:     bool
    is_public_holiday: bool
    is_pandemic:       bool = False

CURRENT_THR = 90

# simulate_api.py (part 2 of 2)

import random, datetime as dt
import simpy
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# ─── 7) Bus process ────────────────────────────────────────────────
LOG = []

class Bus:
    def __init__(self,
                 env: simpy.Environment,
                 name: str,
                 dep: dt.datetime,
                 sc: Scenario,
                 headway: int):
        self.env      = env
        self.name     = name
        self.dep      = dep
        self.sc       = sc
        self.headway  = headway
        self.curr     = dep
        self.seg      = SEG_DF.copy()
        self.pax      = []
        self.max_occ  = 0
        self.boarded  = 0
        self.lags     = [0]*5
        env.process(self.run())

    def run(self):
        # departure delay from midnight
        start = (self.dep - dt.datetime.combine(self.dep.date(), dt.time())).seconds / 60
        yield self.env.timeout(start)

        trip_time = 0.0
        for r in self.seg.itertuples():
            now, stop, km = self.curr, r.stop, r.km

            # travel via CatBoost + weather
            feat = make_features(now, self.sc, km, self.lags)
            sec  = float(CAT.predict([feat])[0])
            dur  = sec/60
            if self.sc.weather_desc in ("Storm","Precipitation"):
                dur *= 1.1
            self.lags = [dur] + self.lags[:4]
            trip_time += dur
            yield self.env.timeout(dur)
            self.curr += dt.timedelta(minutes=dur)

            # alight
            out = [p for p in self.pax if p == stop]
            self.pax = [p for p in self.pax if p != stop]

            # board (Poisson + gravity)
            lam = get_stop_lambda(stop, now) * ARRIVAL_SCALE * self.sc.demand_multiplier
            if self.sc.is_public_holiday:
                lam *= 0.8
            nin = np.random.poisson(lam * dur)
            dests, probs = DEST_MAP.get(stop, ([], []))
            new = (np.random.choice(dests, size=nin, p=probs).tolist()
                   if dests else [stop]*nin)
            self.pax.extend(new)
            self.boarded += nin
            self.max_occ = max(self.max_occ, len(self.pax))

            # dwell time
            dwell = (r.dwell_sec / 60) + len(out)*0.03 + nin*0.01
            if self.sc.is_school_day:
                dwell *= 1.1
            if self.sc.is_public_holiday:
                dwell *= 1.2
            trip_time += dwell
            yield self.env.timeout(dwell)
            self.curr += dt.timedelta(minutes=dwell)

        # log final trip
        LOG.append({
            "trip":        self.name,
            "depart_time": self.dep.strftime("%H:%M"),
            "headway":     self.headway,
            "bus_type":    self.sc.bus_type.name,
            "capacity":    self.sc.bus_type.capacity,
            "max_occ":     self.max_occ,
            "boarded":     self.boarded,
            "trip_time":   round(trip_time,2),
            "load_%":      round(100*self.max_occ/self.sc.bus_type.capacity,2)
        })

# ─── 8) run_day orchestration ───────────────────────────────────────
def run_day(sc: Scenario, slot_plan: List[Tuple[str,int]]) -> pd.DataFrame:
    global LOG
    LOG = []
    env = simpy.Environment()
    for idx,(s,h) in enumerate(slot_plan):
        dep = dt.datetime.combine(dt.date.today(), pd.to_datetime(s).time())
        exp = estimate_expected_load(dep, sc)
        sc.bus_type = ARTIC if exp > CURRENT_THR else STD
        Bus(env, f"Trip{idx}", dep, sc, h)
    env.run()
    return pd.DataFrame(LOG)

# ─── 9) FastAPI endpoint ───────────────────────────────────────────
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class SimRequest(BaseModel):
    weather_desc:      str
    temp:              float
    demand_multiplier: float
    is_school_day:     bool
    is_public_holiday: bool
    is_pandemic:       bool   = False
    threshold:         int
    slots:             List[List[str]]

@app.post("/simulate")
async def simulate(req: SimRequest):
    global CURRENT_THR
    CURRENT_THR = req.threshold

    # build scenario
    sc = Scenario(
        weather_desc      = req.weather_desc,
        temp              = req.temp,
        demand_multiplier = req.demand_multiplier,
        is_school_day     = req.is_school_day,
        is_public_holiday = req.is_public_holiday,
        is_pandemic       = req.is_pandemic
    )

    # parse slots (each slot is [\"HH:MM\", headway_minutes])
    slot_plan = [(s, int(h)) for s,h in req.slots]

    # run simulation
    df = run_day(sc, slot_plan)

    # return JSON records
    return df.to_dict(orient="records")
